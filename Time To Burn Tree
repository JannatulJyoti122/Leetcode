#include<bits/stdc++.h>
/************************************************************

    Following is the Binary Tree node structure

    class BinaryTreeNode 
    {
        public : 
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;

        BinaryTreeNode(T data) 
        {
            this -> data = data;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/


int find(BinaryTreeNode<int> *node,map<BinaryTreeNode<int>*,BinaryTreeNode<int>*>&parent,map<int,int>&mp){
    if(node==NULL) return 0;
    if(node->left==NULL&& node->right==NULL){
        mp[node->data]=1;
        return 1;
    }
    mp[node->data]=1;
    int left=0;
    if(node->left!=NULL&& mp[node->left->data]==0) left=find(node->left,parent,mp);
    int right=0;
    if(node->right!=NULL&&mp[node->right->data]==0) right=find(node->right,parent,mp);
    int up=0;
    if(parent[node]!=NULL&&mp[parent[node]->data]==0) up=find(parent[node],parent,mp);
    
    return max(left,max(right,up))+1;
}

int timeToBurnTree(BinaryTreeNode<int>* root, int start)
{
    // Write your code here
    map<BinaryTreeNode<int>*,BinaryTreeNode<int>*>parent;
    queue<BinaryTreeNode<int>*>q;
    q.push(root);
    parent[root]=NULL;
    BinaryTreeNode<int> *startNode;
    while(!q.empty()){
        BinaryTreeNode<int> *temp=q.front();
        q.pop();
        if(temp->data==start) startNode=temp;
        if(temp->left){
            parent[temp->left]=temp;
            q.push(temp->left);
        }

        if(temp->right){
            parent[temp->right]=temp;
            q.push(temp->right);
        }

    }
    map<int,int>mp;
    BinaryTreeNode<int>* node=startNode;
    mp[startNode->data]=1;
    int left=0;
    left=find(node->left,parent,mp);
    int right=0;
    right=find(node->right,parent,mp);
    int up=0;
    up=find(parent[node],parent,mp);
    
    return max(left,max(right,up));

}
